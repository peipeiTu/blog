---
title: "数字货币钱包的生成以及在nodejs下的实际操作"
date: "2020-04-13T01:06:00.000Z"
description: "数字货币钱包的助记词、种子、私钥、公钥、地址等等的生成方式，以及在nodejs下的实际操作"
type: "区块链"
---

### 不确定性（随机）钱包
最古老的钱包方式，钱包里的所有私钥都是随机生成的，私钥之间彼此独立。相当于只要新生成了钱包，就需要及时备份，不然一旦钱包文件损坏，所有币也就找不回来了。

因为这种不方便的特性，不确定钱包已经不被推荐使用，而使用确定性钱包代替，所以这一项就不展开说了。

### 确定性（种子）钱包
确定性钱包中的所有私钥，都来自于一个随机种子（Seed），计算单向，相当于一个种子可以生成很多地址，那么只要备份了种子，那么所有的私钥就都可以重新恢复。

### 分层确定性钱包
根据陆续的多个提案，实现了一种确定性钱包，称为分层确定性（HD，Hierarchical Deterministic）钱包。

“分层”的意思是，钱包中私钥具有层级关系。
“确定性”的意思是，当种子确定后，钱包中的所有私钥便都是确定的，都可以从这个种子计算出来。

主要BIP有：
* BIP-32：HD钱包中的密钥如何衍生
* BIP-39：HD钱包助记词（Mnemonic）和种子（Seed）的创建规则
* BIP-44：支持多币种和多账户的HD钱包

### BIP-39

#### 1. 从熵源创建`助记词`
1. 取一串有L个二进制位的随机序列（熵）S1，L可以是128、160、192、224或256
2. 对S1做SHA256运算，得到S2
3. 把S2的高 $\frac{L}{32}$ 位作为校验和拼接在S1后，得到S3，显而易见，S3的长度可以被11整除
$$L + \frac{L}{32} = \frac{33L}{32} = 11 * \frac{3L}{32}$$

4. 从高位到低位，将S3每11位划成一组，每组二进制序列都可以转换成一个十进制数，表示单词表中的行数
5. BIP-39定义的单词表中有2048个单词，每个单词一行（行数从0开始计数），在表中查找这些行数上的单词
6. 将这些单词按顺序抄写下来，就是助记词

#### 2. 从助记词创建`种子`
种子由助记词通过`PBKDF2(Password-Based Key Derivation Function 2)`方法计算得到。计算过程如下：
1. 获取助记词。
2. 获取盐（Salt），由`mnemonic`这个单词和用户指定的密码(Passphrase)拼接而成，密码可以为空。
3. 使用`PBKDF2`方法：用HMAC-SHA512哈希算法，做2048次哈希运算来衍生输入，产生一个512位的输出，即为我们想要的种子。

#### 3. nodejs代码
开源项目 [bitcoinjs/bip39](https://github.com/bitcoinjs/bip39)：
```javascript
const bip39 = require('bip39');
/** 下面的方法很多也有异步的写法，这里就只写同步写法了 */

/** 随机初始化助记词，默认为128位（12个单词）。可以输入参数控制长度 */
const mnemonic = bip39.generateMnemonic();

/** 校验助记词是否有效 */
bip39.validateMnemonic('basket actual')
```

### BIP-32
`BIP-32`定义，HD钱包使用`HMAC-SHA512`方法从种子衍生主私钥

#### 1. 从种子衍生主密钥
`HMAC-SHA512`使用`SHA512`哈希算法，以一个消息(Message)和一个密钥(Key)作为输入，生成512位（64字节）的消息摘要(Digest)作为输出。

从种子计算主私钥时，种子作为输入的消息，自定义的字符串作为输入的密钥，计算产生512位的输出。

输出的高256位，是主私钥。
输出的低256位，是主链码。